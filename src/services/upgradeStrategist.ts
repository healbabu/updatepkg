import * as vscode from 'vscode';
import { Logger } from '../utils/logger';
import { CopilotService } from './copilotService';

export interface PackageUpdate {
    packageName: string;
    currentVersion: string;
    recommendedVersion: string;
    projectPath: string;
}

export interface UpgradeStrategy {
    name: string;
    description: string;
    phases: UpgradePhase[];
    aiReasoning?: string;
}

export interface UpgradePhase {
    name: string;
    description: string;
    packages: PackageUpdate[];
    order: number;
}

export type SuggestionMode = 'simple' | 'comprehensive' | 'ai';

/**
 * Simplified Upgrade Strategist - AI-first approach with fallback
 * Replaces complex multi-stage PackageFamilyDetector with direct AI strategy generation
 */
export class UpgradeStrategist {
    private logger: Logger;
    private copilotService: CopilotService;

    constructor(logger: Logger) {
        this.logger = logger;
        this.copilotService = new CopilotService(logger);
    }

    /**
     * Generate upgrade strategy using AI-first approach
     * @param updates - List of package updates to strategize
     * @param mode - Strategy generation mode (defaults to 'ai')
     * @param dependencyInfo - Optional dependency information
     */
    async generateUpgradeStrategy(
        updates: PackageUpdate[], 
        mode: SuggestionMode = 'ai',
        dependencyInfo?: any
    ): Promise<UpgradeStrategy> {
        this.logger.info(`Generating upgrade strategy for ${updates.length} packages using ${mode} mode`);

        try {
            // AI-first approach - try to get intelligent strategy from Copilot
            if (mode === 'ai' || mode === 'comprehensive') {
                this.logger.info('Attempting AI-powered strategy generation...');
                
                const aiStrategy = await this.generateAIStrategy(updates, dependencyInfo);
                if (aiStrategy) {
                    this.logger.info('Successfully generated AI-powered upgrade strategy');
                    return aiStrategy;
                }
                
                this.logger.warn('AI strategy generation failed, falling back to prefix-based grouping');
            }

            // Fallback to simple prefix-based grouping
            this.logger.info('Using fallback prefix-based strategy');
            return this.generateFallbackStrategy(updates);

        } catch (error) {
            this.logger.error('Strategy generation failed, using emergency fallback', error);
            return this.generateEmergencyFallbackStrategy(updates);
        }
    }

    /**
     * Generate AI-powered strategy using CopilotService
     */
    private async generateAIStrategy(
        updates: PackageUpdate[], 
        dependencyInfo?: any
    ): Promise<UpgradeStrategy | null> {
        try {
            // Use CopilotService to generate strategy
            const updateSummary = {
                totalUpdates: updates.length,
                updates: updates,
                hasBreakingChanges: this.detectPotentialBreakingChanges(updates)
            };

            const aiResponse = await this.copilotService.generateUpgradeStrategy(
                updateSummary, 
                dependencyInfo
            );

            // Parse AI response and convert to our strategy format
            const parsedStrategy = JSON.parse(aiResponse);
            
            return {
                name: parsedStrategy.name || 'AI-Generated Strategy',
                description: parsedStrategy.description || 'Intelligent upgrade strategy generated by AI',
                phases: this.convertToPhases(parsedStrategy.packages || updates),
                aiReasoning: parsedStrategy.aiReasoning
            };

        } catch (error) {
            this.logger.warn('AI strategy generation failed', error);
            return null;
        }
    }

    /**
     * Generate fallback strategy using simple prefix-based grouping
     */
    private generateFallbackStrategy(updates: PackageUpdate[]): UpgradeStrategy {
        this.logger.info('Generating fallback strategy with prefix-based grouping');

        // Group packages by simple prefix rules
        const microsoftPackages = updates.filter(u => u.packageName.startsWith('Microsoft.'));
        const systemPackages = updates.filter(u => u.packageName.startsWith('System.'));
        const otherPackages = updates.filter(u => 
            !u.packageName.startsWith('Microsoft.') && 
            !u.packageName.startsWith('System.')
        );

        const phases: UpgradePhase[] = [];

        // Phase 1: Microsoft framework packages (highest priority)
        if (microsoftPackages.length > 0) {
            phases.push({
                name: 'Framework Updates',
                description: `Upgrade ${microsoftPackages.length} Microsoft framework packages first`,
                packages: microsoftPackages,
                order: 1
            });
        }

        // Phase 2: System packages
        if (systemPackages.length > 0) {
            phases.push({
                name: 'System Updates',
                description: `Upgrade ${systemPackages.length} System packages`,
                packages: systemPackages,
                order: 2
            });
        }

        // Phase 3: Other packages
        if (otherPackages.length > 0) {
            phases.push({
                name: 'Third-Party Updates',
                description: `Upgrade ${otherPackages.length} third-party packages`,
                packages: otherPackages,
                order: 3
            });
        }

        return {
            name: 'Prefix-Based Sequential Strategy',
            description: `Upgrade packages in ${phases.length} phases based on package prefixes`,
            phases: phases,
            aiReasoning: 'Fallback strategy: Microsoft packages first, then System packages, then third-party packages'
        };
    }

    /**
     * Emergency fallback - just upgrade everything sequentially
     */
    private generateEmergencyFallbackStrategy(updates: PackageUpdate[]): UpgradeStrategy {
        this.logger.warn('Using emergency fallback strategy - sequential upgrade');

        return {
            name: 'Sequential Emergency Strategy',
            description: `Upgrade all ${updates.length} packages sequentially`,
            phases: [{
                name: 'All Packages',
                description: 'Upgrade all packages in order',
                packages: updates,
                order: 1
            }],
            aiReasoning: 'Emergency fallback: upgrading all packages sequentially due to strategy generation failure'
        };
    }

    /**
     * Convert flat package list to phases
     */
    private convertToPhases(packages: PackageUpdate[]): UpgradePhase[] {
        // Simple conversion - put all packages in one phase
        // AI should have already organized them properly
        return [{
            name: 'AI-Organized Updates',
            description: `Upgrade ${packages.length} packages in AI-recommended order`,
            packages: packages,
            order: 1
        }];
    }

    /**
     * Detect potential breaking changes based on version jumps
     */
    private detectPotentialBreakingChanges(updates: PackageUpdate[]): boolean {
        return updates.some(update => {
            try {
                const currentMajor = parseInt(update.currentVersion.split('.')[0]);
                const recommendedMajor = parseInt(update.recommendedVersion.split('.')[0]);
                return recommendedMajor > currentMajor;
            } catch {
                return false;
            }
        });
    }

    /**
     * Get configuration for dependency analysis
     */
    private isDependencyAnalysisEnabled(): boolean {
        const config = vscode.workspace.getConfiguration('dotnetPackageUpgrader');
        return config.get<boolean>('enableDependencyAnalysis', true);
    }

    /**
     * Generate strategy with timeout protection
     */
    async generateUpgradeStrategyWithTimeout(
        updates: PackageUpdate[], 
        mode: SuggestionMode = 'ai',
        dependencyInfo?: any,
        timeoutMs: number = 30000
    ): Promise<UpgradeStrategy> {
        this.logger.info(`Generating upgrade strategy with ${timeoutMs}ms timeout`);

        return Promise.race([
            this.generateUpgradeStrategy(updates, mode, dependencyInfo),
            new Promise<UpgradeStrategy>((_, reject) => 
                setTimeout(() => reject(new Error('Strategy generation timeout')), timeoutMs)
            )
        ]).catch(error => {
            this.logger.warn('Strategy generation timed out or failed, using emergency fallback', error);
            return this.generateEmergencyFallbackStrategy(updates);
        });
    }
} 